# Ответы 3.3

## Теория
1. Настройка окружения для генератора квизов включает импорт необходимых библиотек, подавление несущественных предупреждений и загрузку API-ключей (CircleCI, GitHub, OpenAI).
2. Структура датасета должна включать шаблон вопроса и «банк квизов», организованный по темам, категориям и фактам. Например: «История», «Технологии», «География» с соответствующими фактами.
3. Инженерия промптов направляет ИИ на генерацию контента, релевантного выбранной категории. Шаблон промпта может предписывать выбор тем из банка и формирование вопросов квиза.
4. Роль LangChain заключается в структурировании промпта, выборе языковой модели (LLM) и настройке парсера для обработки вывода.
5. Пайплайн генерации квиза представляет собой связку структурированного промпта, модели и парсера, реализованную с использованием LangChain Expression Language.
6. Для оценки релевантности и корректности сгенерированного контента квиза используются функции, такие как `evaluate_quiz_content`, которые проверяют наличие ожидаемых ключевых слов.
7. Проверка корректного отказа осуществляется с помощью функции `evaluate_request_refusal`, которая убеждается, что система возвращает ожидаемый отказ на запросы, выходящие за рамки ее компетенции.
8. Тест «наука» проверяет, что сгенерированные вопросы содержат индикаторы научной тематики (например, «физика», «химия», «биология», «астрономия»).
9. Базовые компоненты конфигурации CircleCI для Python-проекта включают: версию, орбы, задания (сборка/тестирование), образ Docker, шаги (извлечение кода/тесты) и рабочие процессы (workflows).
10. Кастомизация конфигурации CircleCI под проект предполагает настройку версии Python, команд для запуска тестов и добавление дополнительных шагов, чтобы точно отразить реальные процессы сборки, тестирования и развертывания.

## Практика
Решения к заданиям:

### Задача 1: Создание датасета квиза

Мы определим Python-словарь, который представляет собой коллекцию вопросов квиза, организуя их по предметам, каждый со своими категориями и фактами.

```python
quiz_bank = {
    "Historical Conflict": {
        "categories": ["History", "Politics"],
        "facts": [
            "Began in 1914 and ended in 1918",
            "Involved two major alliances: the Allies and the Central Powers",
            "Known for the extensive use of trench warfare on the Western Front"
        ]
    },
    "Revolutionary Communication Technology": {
        "categories": ["Technology", "History"],
        "facts": [
            "Invented by Alexander Graham Bell in 1876",
            "Revolutionized long-distance communication",
            "First words transmitted were 'Mr. Watson, come here, I want to see you'"
        ]
    },
    "Iconic American Landmark": {
        "categories": ["Geography", "History"],
        "facts": [
            "Gifted to the United States by France in 1886",
            "Symbolizes freedom and democracy",
            "Located on Liberty Island in New York Harbor"
        ]
    }
}
```

### Задача 2: Генерация вопросов квиза с использованием промптов

Для этой функции мы будем генерировать вопросы квиза на основе заданной категории, обращаясь к релевантным предметам и фактам из `quiz_bank`. Этот подход демонстрирует, как манипулировать и форматировать строки в Python для конструирования осмысленных вопросов квиза.

```python
def generate_quiz_questions(category):
    # Список для хранения сгенерированных вопросов
    generated_questions = []

    # Перебираем каждый предмет в банке квизов
    for subject, details in quiz_bank.items():
        # Проверяем, есть ли категория в категориях предмета
        if category in details["categories"]:
            # Для каждого факта создаем вопрос и добавляем его в список
            for fact in details["facts"]:
                question = f"Что описывается следующим фактом: {fact}? Ответ: {subject}."
                generated_questions.append(question)
    
    return generated_questions

# Пример использования
history_questions = generate_quiz_questions("History")
for question in history_questions:
    print(question)
```


### Задача 3: Реализация структурирования промптов LangChain

Для симуляции структурирования промпта квиза, как это может быть сделано с использованием LangChain, мы можем определить Python-функцию, которая форматирует список вопросов квиза в структурированный промпт. Этот структурированный промпт предназначен для имитации детальных инструкций и форматирования, которые направляли бы ИИ-модель в генерации или обработке контента квиза.

```python
def structure_quiz_prompt(quiz_questions):
    # Define a delimiter for separating questions
    section_delimiter = "####"
    
    # Start with an introductory instruction
    structured_prompt = "Инструкции для генерации индивидуального квиза:\nКаждый вопрос отделен четырьмя символами решетки (####)\n\n"
    
    # Add each question, separated by the delimiter
    for question in quiz_questions:
        structured_prompt += f"{section_delimiter}\n{question}\n"
    
    return structured_prompt

# Пример использования
quiz_questions = [
    "В каком году была подписана Декларация независимости?",
    "Кто изобрел телефон?"
]
print(structure_quiz_prompt(quiz_questions))
```

Эта функция принимает список вопросов квиза и возвращает одну строку, которая структурирует эти вопросы таким образом, чтобы симулировать вход для ИИ-модели генерации квиза, используя указанный разделитель для разделения вопросов.

### Задача 4: Пайплайн генерации квиза
```python
def generate_quiz_questions(category):
    """
    Симулирует генерацию вопросов квиза на основе категории.
    """
    # Заглушка для простой логики генерации вопросов на основе категории
    questions = {
        "Science": ["Что такое химический символ воды?", "Какая планета известна как Красная планета?"],
        "History": ["Кто был первым президентом Соединенных Штатов?", "В каком году затонул Титаник?"]
    }
    return questions.get(category, [])

def structure_quiz_prompt(quiz_questions):
    """
    Структурирует чат-промпт с предоставленными вопросами квиза.
    """
    section_delimiter = "####"
    prompt = "Сгенерированные вопросы квиза:\n\n"
    for question in quiz_questions:
        prompt += f"{section_delimiter} Вопрос: {question}\n"
    return prompt

def select_language_model():
    """
    Симулирует выбор языковой модели.
    """
    # Для этого примера мы предположим, что модель - это константная строка
    return "gpt-3.5-turbo"

def execute_language_model(prompt):
    """
    Симулирует выполнение выбранной языковой модели с заданным промптом.
    """
    # Эта функция обычно отправляла бы промпт в модель и получала вывод.
    # Здесь мы симулируем это, повторяя промпт с подтверждением.
    return f"Модель получила следующий промпт: {prompt}\nМодель: 'Вопросы квиза успешно структурированы.'"

def format_model_output(model_output):
    """
    Форматирует вывод из языковой модели.
    """
    # Симулируем парсинг и форматирование вывода модели для читаемости
    return f"Отформатированный вывод модели:\n{model_output}"

def generate_quiz_pipeline(category="Science"):
    """
    Расширенный пайплайн генерации квиза, который симулирует каждый шаг в процессе генерации квиза.
    """
    print("Настройка пайплайна генерации квиза...")
    quiz_questions = generate_quiz_questions(category)
    print("Вопросы квиза сгенерированы на основе категории.")
    
    structured_prompt = structure_quiz_prompt(quiz_questions)
    print("Структурирование чат-промпта с предоставленными вопросами квиза...")
    
    model = select_language_model()
    print(f"Выбрана языковая модель: {model}")
    
    model_output = execute_language_model(structured_prompt)
    print("Выполнение языковой модели со структурированным промптом...")
    
    formatted_output = format_model_output(model_output)
    print("Настройка парсера вывода для форматирования ответа ИИ-модели...")
    
    print(formatted_output)
    print("Квиз успешно сгенерирован!")
    
# Пример использования с указанной категорией
generate_quiz_pipeline("History")
```

### Задача 5: Переиспользуемая функция генерации квиза

Эта функция симулирует сборку необходимых компонентов для генерации квизов, таких как создание детального системного промпта на основе предоставленных параметров и симуляция выбора языковой модели и парсера вывода.

```python
def create_structured_prompt(system_prompt_message, user_question_template):
    """
    Симулирует создание структурированного промпта, объединяющего системные инструкции и шаблон пользовательского вопроса.
    """
    return f"{system_prompt_message}\n\nШаблон для вопросов: {user_question_template}"

def select_language_model():
    """
    Симулирует выбор языковой модели с конкретными конфигурациями.
    """
    # Заглушка для выбора модели
    model_name = "GPT-3.5-turbo"
    temperature = 0
    return model_name, temperature

def simulate_model_response(structured_prompt):
    """
    Симулирует генерацию ответа из выбранной языковой модели на основе структурированного промпта.
    """
    # Здесь происходил бы фактический API вызов к языковой модели
    # Для целей симуляции мы вернем мок-ответ
    return "Сгенерирован макет квиза на основе структурированного промпта."

def setup_output_parser(model_output):
    """
    Симулирует настройку парсера вывода для форматирования ответа модели.
    """
    # Простое форматирование для демонстрации
    formatted_output = f"Отформатированный квиз: {model_output}"
    return formatted_output

def generate_quiz_assistant_pipeline(system_prompt_message, user_question_template="{question}"):
    print("Создание структурированного промпта с системным сообщением и шаблоном пользовательского вопроса...")
    structured_prompt = create_structured_prompt(system_prompt_message, user_question_template)
    
    print("Выбор языковой модели: GPT-3.5-turbo с температурой 0")
    model_name, temperature = select_language_model()
    
    print("Симуляция ответа языковой модели...")
    model_output = simulate_model_response(structured_prompt)
    
    print("Настройка парсера вывода для форматирования ответов")
    formatted_output = setup_output_parser(model_output)
    
    print("Сборка компонентов в пайплайн генерации квиза...")
    return formatted_output

# Пример использования с детальным системным промптом
system_prompt_message = "Пожалуйста, сгенерируйте квиз на основе следующих категорий: Наука, История."
print(generate_quiz_assistant_pipeline(system_prompt_message))
```

Эти функции предоставляют базовую симуляцию процессов, вовлеченных в структурирование промптов для генерации квизов на базе ИИ, сборку пайплайна для выполнения этой генерации и создание повторно используемой функции для генерации квизов с настраиваемыми параметрами.


### Задача 6: Оценка сгенерированного контента квиза

Эта функция принимает сгенерированный контент квиза и список ожидаемых ключевых слов в качестве входных данных, чтобы убедиться, что сгенерированный контент соответствует ожидаемым темам или предметам. Она вызывает ошибку утверждения, если контент не содержит ни одного из ожидаемых ключевых слов, указывая на несоответствие между ожидаемым и сгенерированным контентом.

```python
def evaluate_quiz_content(generated_content, expected_keywords):
    # Проверяем, есть ли какие-либо из ожидаемых ключевых слов в сгенерированном контенте
    if not any(keyword.lower() in generated_content.lower() for keyword in expected_keywords):
        raise AssertionError("Сгенерированный контент не содержит ни одного из ожидаемых ключевых слов.")
    else:
        print("Сгенерированный контент успешно содержит ожидаемые ключевые слова.")

# Пример использования
generated_content = "Закон всемирного тяготения был сформулирован Исааком Ньютоном в 17 веке."
expected_keywords = ["гравитация", "Ньютон", "физика"]
evaluate_quiz_content(generated_content, expected_keywords)
```

### Задача 7: Обработка недействительных запросов квиза

Эта функция симулирует оценку ответа системы на недействительный запрос квиза. Она проверяет, соответствует ли сгенерированный ответ об отказе ожидаемому ответу об отказе, подтверждая корректность обработки системой запросов, которые не могут быть выполнены.

```python
def evaluate_request_refusal(invalid_request, expected_response):
    # Симулируем генерацию ответа на недействительный запрос
    generated_response = f"Невозможно сгенерировать квиз для: {invalid_request}"  # Заглушка для фактического ответа об отказе
    
    # Проверяем, соответствует ли сгенерированный ответ ожидаемому ответу об отказе
    assert generated_response == expected_response, "Ответ об отказе не соответствует ожидаемому ответу."
    print("Ответ об отказе корректно соответствует ожидаемому ответу.")

# Пример использования
invalid_request = "Сгенерировать квиз о единорогах."
expected_response = "Невозможно сгенерировать квиз для: Сгенерировать квиз о единорогах."
evaluate_request_refusal(invalid_request, expected_response)
```

### Задача 8: Тест оценки научного квиза

Эта функция демонстрирует использование функции `evaluate_quiz_content` в конкретном тестовом сценарии — проверке того, что сгенерированный научный квиз содержит вопросы, относящиеся к ожидаемым научным темам. Она симулирует генерацию контента квиза, а затем оценивает его на наличие научно-ориентированных ключевых слов.

```python
def test_science_quiz():
    # Симулируем генерацию контента квиза
    generated_content = "Изучение естественного мира посредством наблюдения и эксперимента известно как наука. Ключевые предметы включают биологию, химию, физику и науки о Земле."
    
    # Определяем ожидаемые ключевые слова или предметы для научного квиза
    expected_science_subjects = ["биология", "химия", "физика", "науки о Земле"]
    
    # Используем функцию evaluate_quiz_content для проверки наличия ожидаемых ключевых слов
    try:
        evaluate_quiz_content(generated_content, expected_science_subjects)
        print("Оценка содержания научного квиза пройдена успешно.")
    except AssertionError as e:
        print(f"Оценка содержания научного квиза не пройдена: {e}")

# Пример использования
test_science_quiz()
```

Эти функции в совокупности предоставляют механизмы для оценки релевантности и точности сгенерированного контента квиза, соответствующей обработки недействительных запросов и проведения целенаправленных тестов на контент квиза для обеспечения его соответствия конкретным образовательным или тематическим критериям.
