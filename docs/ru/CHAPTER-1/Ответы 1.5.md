# Ответы 1.5

## Теория

1.  **Чейнинг промптов** — это декомпозиция сложной задачи на последовательные, взаимосвязанные шаги или промпты, где каждый решает подзадачу. В отличие от «монолитного» подхода, это упрощает процесс и повышает управляемость.
2.  Для наглядности чейнинг промптов можно сравнить с поэтапной готовкой сложного блюда или модульной разработкой, где каждая часть вносит свой вклад в конечный результат.
3.  **Управление воркфлоу** в чейнинге предполагает фиксацию состояния на каждом шаге и адаптацию следующего шага под полученные результаты.
4.  **Экономия ресурсов**: обрабатывая только необходимую информацию на каждом этапе, чейнинг промптов сокращает вычисления по сравнению с одним длинным промптом.
5.  **Снижение количества ошибок**: фокус на одной подзадаче упрощает отладку и позволяет точечно улучшать модель.
6.  **Динамическая подгрузка информации** важна из-за ограничений контекста моделей; чейнинг позволяет подключать релевантные данные по мере необходимости.
7.  Основные шаги чейнинга: декомпозиция задачи, управление состоянием, дизайн промптов, загрузка/предобработка данных, динамическая подстройка контекста.
8.  **Лучшие практики**: избегать ненужного усложнения, использовать ясные промпты, осуществлять внешний менеджмент контекста, стремиться к эффективности, проводить непрерывное тестирование и улучшения.
9.  В примерах для конфигурации и работы с API используются библиотеки `dotenv` и `openai`.
10. **System-сообщение** задаёт структуру и формат ответов, что повышает их точность и согласованность.
11. **База товаров** хранит детали продуктов; функции выборки по имени или категории используются для эффективных ответов службы поддержки.
12. **Преобразование JSON-строк** в объекты Python упрощает последующую обработку в цепочках промптов.
13. **Формирование пользовательского ответа** из данных делает общение информативным и уместным.
14. Чейнинг позволяет системе последовательно переходить от обработки запроса к диагностике, вопросам гарантии и рекомендациям, охватывая комплексные сценарии обслуживания.

## Практика

1.  **Функция `retrieve_model_response`**:
    ```python
    from openai import OpenAI

    client = OpenAI()

    def retrieve_model_response(message_sequence, model="gpt-4o-mini", temperature=0, max_tokens=500):
        response = client.chat.completions.create(
            model=model,
            messages=message_sequence,
            temperature=temperature,
            max_tokens=max_tokens,
        )
        return response.choices[0].message.content
    ```

2.  **Извлечение информации о продуктах и категориях**:
    ```python
    # Системное сообщение, определяющее структуру задачи и ожидаемый формат ответа
    system_instruction = """
    Вам будут предоставлены запросы службы поддержки. Запрос будет ограничен символами '####'.
    Выведите Python-список объектов, каждый из которых представляет продукт или категорию, упомянутую в запросе.
    """

    # Пример пользовательского запроса о конкретных продуктах и категориях
    user_query = "#### Расскажите мне о SmartX ProPhone и FotoSnap DSLR Camera, а также о ваших телевизорах ####"

    # Подготавливаем последовательность сообщений для модели
    message_sequence = [
        {'role': 'system', 'content': system_instruction},
        {'role': 'user', 'content': user_query},
    ]

    # Используем функцию для получения ответа модели
    extracted_info = retrieve_model_response(message_sequence)
    print(extracted_info)
    ```

3.  **Функции для работы с базой данных продуктов**:
    ```python
    # Пример базы данных продуктов
    product_database = {
        "SmartX ProPhone": {
            "name": "SmartX ProPhone",
            "category": "Смартфоны и аксессуары",
            # Дополнительные детали продукта...
        },
        "FotoSnap DSLR Camera": {
            "name": "FotoSnap DSLR Camera",
            "category": "Камеры и фотография",
            # Дополнительные детали продукта...
        },
        "UltraView HD TV": {
            "name": "UltraView HD TV",
            "category": "Телевизоры",
            # Дополнительные детали продукта...
        },
        # Другие продукты...
    }

    # Функция для получения информации о продукте по имени
    def get_product_details_by_name(product_name):
        return product_database.get(product_name, "Продукт не найден.")

    # Функция для получения всех продуктов в определенной категории
    def get_products_in_category(category_name):
        return [product for product_name, product in product_database.items() if product["category"] == category_name]

    # Пример использования
    print(get_product_details_by_name("SmartX ProPhone"))
    print(get_products_in_category("Смартфоны и аксессуары"))
    ```

4.  **Преобразование JSON-строки в список Python**:
    ```python
    import json

    def json_string_to_python_list(json_string):
        try:
            return json.loads(json_string)
        except json.JSONDecodeError as e:
            print(f"Ошибка декодирования JSON: {e}")
            return None

    # Пример JSON строки
    json_input = '[{"category": "Смартфоны и аксессуары", "products": ["SmartX ProPhone"]}]'

    # Конвертируем и выводим Python список
    python_list = json_string_to_python_list(json_input)
    print(python_list)
    ```

5.  **Генерация ответа на основе данных**:
    ```python
    def generate_response_from_data(product_data_list):
        if not product_data_list:
            return "Мы не смогли найти продукты, соответствующие вашему запросу."

        response_string = ""
        for product_data in product_data_list:
            response_string += f"Название продукта: {product_data['name']}\n"
            response_string += f"Категория: {product_data['category']}\n"
            response_string += "\n"  # Добавляем перенос строки для разделения продуктов

        return response_string

    # Предполагаем, что python_list - это результат предыдущего преобразования JSON в Python список
    python_list = [{'category': 'Смартфоны и аксессуары', 'products': ['SmartX ProPhone']}]
    final_response = generate_response_from_data(python_list)
    print(final_response)
    ```

6.  **Сквозной сценарий обработки запросов в службе поддержки**:
    Давайте опишем сценарий, где ИИ службы поддержки обрабатывает первоначальный запрос о продукте, обрабатывает запрос на устранение неполадок, отвечает на вопрос о гарантии и предлагает дополнительные рекомендации по продуктам. Этот сценарий основан на предыдущих функциях.

    ### Шаги сценария

    1.  **Первоначальный запрос о продукте**
        *   **Запрос пользователя:** "Я заинтересован в обновлении моего смартфона. Что вы можете рассказать о последних моделях?"
        *   **Процесс ИИ:** ИИ использует `retrieve_model_response` для извлечения релевантных названий продуктов из запроса, а затем получает детали для этих продуктов с помощью `get_product_details_by_name`.
        *   **Ответ ИИ:** ИИ форматирует эту информацию с помощью `generate_response_from_data` и отвечает с деталями о последних моделях смартфонов.

    2.  **Запрос на устранение неполадок**
        *   **Запрос пользователя:** "Я только что купил SmartX ProPhone, но у меня проблемы с автономностью батареи. Что мне делать?"
        *   **Процесс ИИ:** ИИ определяет продукт и проблему, затем консультируется с базой данных по устранению неполадок или руководствами для предоставления конкретных советов.
        *   **Ответ ИИ:** Подробные шаги по устранению неполадок для улучшения автономности батареи или следующие шаги для гарантийного обслуживания.

    3.  **Вопрос о гарантии**
        *   **Запрос пользователя:** "Что покрывает гарантия для SmartX ProPhone?"
        *   **Процесс ИИ:** ИИ получает информацию о гарантии, специфичную для SmartX ProPhone, из своей базы данных.
        *   **Ответ ИИ:** Резюме покрытия гарантии, включая продолжительность и покрываемые проблемы.

    4.  **Дополнительные рекомендации по продуктам**
        *   **Запрос пользователя:** "Есть ли какие-либо аксессуары, которые вы рекомендуете для этого телефона?"
        *   **Процесс ИИ:** На основе информации о продукте ИИ получает список совместимых аксессуаров.
        *   **Ответ ИИ:** ИИ рекомендует аксессуары, такие как чехлы, защитные пленки и беспроводные зарядные устройства, используя `generate_response_from_data` для удобного для пользователя формата.

    ### Пример реализации

    ```python
    # Предполагаем, что все ранее упомянутые функции определены

    # Шаг 1: Обработка первоначального запроса о продукте
    product_inquiry = "Я заинтересован в обновлении моего смартфона. Что вы можете рассказать о последних моделях?"
    # Здесь вы бы симулировали извлечение релевантной информации о продукте и отвечали соответственно.

    # Шаг 2: Обработка запроса на устранение неполадок
    troubleshooting_request = "Я только что купил SmartX ProPhone, но у меня проблемы с автономностью батареи. Что мне делать?"
    # Обрабатываем запрос, определяя общие проблемы и решения для автономности батареи SmartX ProPhone.

    # Шаг 3: Обработка вопроса о гарантии
    warranty_query = "Что покрывает гарантия для SmartX ProPhone?"
    # Получаем и отвечаем с информацией о гарантии, специфичной для SmartX ProPhone.

    # Шаг 4: Дополнительные рекомендации по продуктам
    accessories_query = "Есть ли какие-либо аксессуары, которые вы рекомендуете для этого телефона?"
    # Определяем и рекомендуем совместимые аксессуары для SmartX ProPhone.

    # Каждый из этих шагов включает использование определенных функций для обработки запросов пользователя и генерации информативных, полезных ответов.
    ```

    Этот сценарий демонстрирует серию взаимодействий, которые в совокупности обеспечивают комплексное обслуживание клиентов. Каждый шаг требует специфической обработки ИИ для понимания запроса, получения релевантных данных и форматирования этой информации в четкий ответ.
