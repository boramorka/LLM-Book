# Ответы 1.1

## Теория

1. Основные преимущества интеграции OpenAI API: генерация естественных текстов, автоматизация поддержки, улучшение создания контента и расширение функциональности приложений за счёт продвинутого ИИ — это повышает вовлечённость пользователей и операционную эффективность.
2. Получение и защита API-ключа: зарегистрируйтесь на платформе OpenAI, выберите тарифный план и получите ключ в личном кабинете. Храните ключ в переменных окружения или секрет-хранилищах, не коммитьте его в репозиторий — это предотвращает несанкционированный доступ и потенциальные убытки.
3. Параметр `temperature`: регулирует креативность и вариативность генерируемого текста. Низкое значение приводит к более предсказуемым ответам, высокое — к более разнообразным. Выбирайте значение в зависимости от задачи.
4. Ключи следует хранить вне кода (в переменных окружения или секрет-менеджерах), чтобы исключить их утечки через исходный код и системы контроля версий (VCS).
5. Выбор модели влияет на качество, скорость и стоимость. Необходимо балансировать возможности модели и ресурсные ограничения в соответствии с требованиями конкретного приложения.
6. Метаданные ответа (например, количество токенов в секции `usage`) помогают оптимизировать промпты, управлять затратами и эффективнее использовать API.
7. Интерактивный интерфейс: включает историю диалога, виджеты ввода, кнопку отправки и панели для отображения ответов. Обновление происходит в реальном времени по мере поступления ответа.
8. Лучшие практики: постобработка (коррекция стиля и грамматики), персонализация под контекст пользователя, сбор обратной связи, мониторинг производительности и расходов.
9. Подводные камни: избыточное доверие ответам модели без должных проверок. Необходимы валидация, сочетание автоматического и ручного контроля, постоянный мониторинг и тонкая настройка.
10. Этика и приватность: соблюдайте нормативные требования по работе с данными, прозрачно информируйте пользователей о роли ИИ, внедряйте процессы ревью и коррекции, а также учитывайте социальные последствия.

## Практика

Ниже представлена эволюция скрипта на Python для работы с OpenAI API: от базового запроса до обработки ошибок и использования в CLI.

### Задание 1: базовый запрос к API

```python
from openai import OpenAI

client = OpenAI()

response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "What is the future of AI?"}],
    max_tokens=100,
)

print(response.choices[0].message.content)
```

### Задание 2: безопасная работа с ключом

```python
import os
from openai import OpenAI

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "What is the future of AI?"}],
    max_tokens=100,
)

print(response.choices[0].message.content)
```

### Задание 3: интерпретация ответа

```python
import os
from openai import OpenAI

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "What is the future of AI?"}],
    max_tokens=100,
)

print("Response:", response.choices[0].message.content.strip())
print("Model used:", response.model)
print("Finish reason:", response.choices[0].finish_reason)
```

### Задание 4: обработка ошибок

```python
import os
from openai import OpenAI
from openai import APIConnectionError, RateLimitError, APIStatusError

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

try:
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": "What is the future of AI?"}],
        max_tokens=100,
    )
    print("Response:", response.choices[0].message.content.strip())
    print("Model used:", response.model)
    print("Finish reason:", response.choices[0].finish_reason)
except RateLimitError as e:
    print(f"Rate limit exceeded: {e}")
except APIConnectionError as e:
    print(f"Connection error: {e}")
except APIStatusError as e:
    print(f"API returned an error: {e}")
except Exception as e:
    print(f"Other error occurred: {e}")
```

### Задание 5: CLI-чат без постобработки

```python
from openai import OpenAI
import os

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def chat_with_openai():
    print("Starting chat with OpenAI. Type 'quit' to exit.")
    while True:
        user_input = input("You: ")
        if user_input.lower() == 'quit':
            break
        try:
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": user_input}],
                max_tokens=100,
            )
            print("OpenAI:", response.choices[0].message.content.strip())
        except Exception as e:
            print(f"Error: {e}")

if __name__ == "__main__":
    chat_with_openai()
```

### Задание 6: постобработка ответа

```python
from openai import OpenAI
import os
from textblob import TextBlob

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def post_process_response(response_text):
    blob = TextBlob(response_text)
    corrected_text = str(blob.correct())
    formatted_text = " ".join(corrected_text.split())
    return formatted_text

def chat_with_openai():
    print("Starting chat with OpenAI. Type 'quit' to exit.")
    while True:
        user_input = input("You: ")
        if user_input.lower() == 'quit':
            break
        try:
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": user_input}],
                max_tokens=100,
            )
            processed = post_process_response(response.choices[0].message.content)
            print("OpenAI:", processed)
        except Exception as e:
            print(f"Other error occurred: {e}")

if __name__ == "__main__":
    chat_with_openai()
```

### Задание 7–8 (идеи)

- Генерация структуры поста по теме пользователя с выводом в виде маркированного списка.
- Логирование времени ответа и расхода токенов по каждому вызову в файл для последующего анализа и оптимизации.

